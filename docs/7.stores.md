# Angular 19 Tutorial - Part 7: Stores

## State
An injectable service that can be used to store and manage data reactively. To so we use signals and it's computed and effects capabilities. 

First we start by defining the private state of the store, and its dispatch functions.

```typescript
import { Injectable, computed, effect, signal } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class AuthStore {
  private readonly authState: WritableSignal<UserTokenDto> =
    signal<UserTokenDto>(NULL_USER_TOKEN);
  constructor() {
    const localUserToken = localStorage.getItem('userToken');
    if (!localUserToken) return;
    const userToken = JSON.parse(localUserToken);
    this.authState.set(userToken);
  }
}
public dispatchLogin(userToken: UserTokenDto) {
  this.authState.set(userToken);
}
public dispatchLogout() {
  this.authState.set(NULL_USER_TOKEN);
}
public dispatchRefreshToken(accessToken: string) {
  this.authState.update((state) => ({ ...state, accessToken }));
}

```

## Selectors

To access the state of the store we use computed functions. The convention is to use the word `select` followed by the name of the state. We can compose these computed functions to derive new states.

```typescript
public readonly selectToken: Signal<string> = computed(
    () => this.authState().accessToken
  );

public readonly selectIsAuthenticated: Signal<boolean> = computed(
  () => this.selectToken() !== ''
);
```

## Effects

Effects are functions that are triggered when the state of the store changes. They are used to perform side effects such as logging, analytics, or saving the state to the database.

```typescript
 private readonly localStoreEffect = effect(() => {
    const userToken = this.authState(); // trigger
    // effect
    if (userToken === NULL_USER_TOKEN) {
      localStorage.removeItem('userToken');
    } else {
      localStorage.setItem('userToken', JSON.stringify(userToken));
    }
  });
```

